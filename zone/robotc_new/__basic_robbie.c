#pragma config(Sensor, in1,    potent_right_lift, sensorPotentiometer)
#pragma config(Sensor, in2,    potent_left_lift, sensorPotentiometer)
#pragma config(Sensor, in3,    potent_arm_left, sensorPotentiometer)
#pragma config(Sensor, in4,    potent_arm_right, sensorPotentiometer)
#pragma config(Sensor, in8,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  encoder_right,  sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encoder_left,   sensorQuadEncoder)
#pragma config(Motor,  port1,           roller,        tmotorNone, openLoop)
#pragma config(Motor,  port2,           left_front,    tmotorNone, openLoop)
#pragma config(Motor,  port3,           right_middle,  tmotorNone, openLoop)
#pragma config(Motor,  port4,           left_back,     tmotorNone, openLoop)
#pragma config(Motor,  port5,           lift,          tmotorNone, openLoop)
#pragma config(Motor,  port6,           arm,           tmotorNone, openLoop)
#pragma config(Motor,  port7,           right_front,   tmotorNone, openLoop)
#pragma config(Motor,  port8,           left_middle,   tmotorNone, openLoop)
#pragma config(Motor,  port9,           right_back,    tmotorNone, openLoop)
#pragma config(Motor,  port10,          mogo,          tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "robotc_base_include.c"

// utilitys for numbers
// unfortunately we do not have the safety of C++ templates...

#define max(x, a) (x > a ? x : a)
#define min(x, a) (x < a ? x : a)
#define clamp(x, a, b) (min(b, max(a, x)))

enum constants_id {
	drive_constant_p,
	drive_constant_i,
	drive_constant_d,
	interval_value,
	auton_choice,

	constants_count,
};

string constants_strings[] = {
	"drive_constant_p",
	"drive_constant_i",
	"drive_constant_d",
	"interval_value",
	"auton_choice",
};

float constants[constants_count];

float max_speed = 127.0;

void get_requested_delta(float *left, float *right) {
    int r = (vexRT[Ch1] - vexRT[Ch3]);
    int l = (vexRT[Ch1] + vexRT[Ch3]);

    *left  = abs(l) > 20 ? l : 0;
    *right = abs(r) > 20 ? r : 0;
}

float step_pid(float  constant_p,
               float  constant_i,
               float  constant_d,
               float  requested,
               float  current_value,
               float *last_error,
               float *integral) {
    float error = current_value - requested;

    float derivitive = error - *last_error;
    *last_error      = error;

    if (constant_i != 0 && abs(error) < 50) {
        *integral = *integral + error;
    } else {
        *integral = 0;
    }

    return constant_p * error +
           constant_i * *integral +
           constant_d * derivitive;
}


// These values are exposed here to allow helper functions to access them
float drive_requested_left  = 0.0;
float drive_requested_right = 0.0;

float drive_current_left  = 0.0;
float drive_current_right = 0.0;

float drive_integral_left;
float drive_integral_right;

float drive_last_error_left;
float drive_last_error_right;

//float drive_constant_p = 0.2;
//float drive_constant_i = 0.0;
//float drive_constant_d = 0.1;


task drive_pid() {
    // clear out the encoder
    SensorValue[encoder_left]  = 0;
    SensorValue[encoder_right] = 0;

    drive_current_left  = 0;
    drive_current_right = 0;

    drive_requested_left  = 0;
    drive_requested_right = 0;

    drive_last_error_left  = 0;
    drive_last_error_right = 0;

    drive_integral_left  = 0;
    drive_integral_right = 0;

    constants[drive_constant_p] = 0.2;
    constants[drive_constant_i] = 0.0;
    constants[drive_constant_d] = 0.1;

    bool reset = true;

    while (true) {
    	float f_drive_constant_p = constants[drive_constant_p];
    	float f_drive_constant_i = constants[drive_constant_i];
    	float f_drive_constant_d = constants[drive_constant_d];

        drive_current_left  = -SensorValue[encoder_left];
        drive_current_right = SensorValue[encoder_right];

        // Since pid is only used in autonomous this code is commented out to prevent future problems.
        /*
        // get new usercontrol values here
        float delta_requested_left  = 0;
        float delta_requested_right = 0;

        get_requested_delta(&delta_requested_left, &delta_requested_right);


        if (delta_requested_left == 0 && delta_requested_right == 0) {
            if (reset) {
                requested_left             = 0;
                requested_right            = 0;
                SensorValue[left_encoder]  = 0;
                SensorValue[right_encoder] = 0;

                last_error_left  = 0;
                last_error_right = 0;

                reset = false;
            }
        } else {
            requested_left += delta_requested_left / 20;
            requested_right += delta_requested_right / 20;

            reset = true;
        }
		*/

        float new_left  = step_pid(f_drive_constant_p, f_drive_constant_i, f_drive_constant_d,
                                  drive_requested_left,
                                  drive_current_left,
                                  &drive_last_error_left,
                                  &drive_integral_left);
        float new_right = step_pid(f_drive_constant_p, f_drive_constant_i, f_drive_constant_d,
                                   drive_requested_right,
                                   drive_current_right,
                                   &drive_last_error_right,
                                   &drive_integral_right);

        if (abs(new_left) < 20) new_left = 0;
        if (abs(new_right) < 20) new_right = 0;

        writeDebugStreamLine("r: %.2f %.2f c: %.2f %.2f e: %.2f %.2f", drive_requested_left, drive_requested_right, drive_current_left, drive_current_right, drive_last_error_left, drive_last_error_right);

		//displayLCDNumber(0, 0, SensorValue[encoder_left]);
   		//displayLCDNumber(1, 0, SensorValue[encoder_right]);


        new_left  = clamp(new_left, -max_speed, max_speed);
        new_right = clamp(new_right, -max_speed, max_speed);

        motor[right_middle]       = -new_right;
        motor[right_back] = -new_right;
        motor[right_front] = -new_right;

        motor[left_middle]       = -new_left;
        motor[left_back] = -new_left;
        motor[left_front] = -new_left;
	}
}


float lift_requested_left  = 1580;
float lift_requested_right = 1580;

float lift_current_left;
float lift_current_right;

bool lift_disabled = false;

task lift_pid_loop() {
    SensorValue[potent_left_lift]  = 0;
    SensorValue[potent_right_lift] = 0;

    float last_error_left;
    float last_error_right;

    float integral_left  = 0.0;
    float integral_right = 0.0;

    while (true) {
        if (lift_disabled) {
            continue;
        }

        lift_current_left = SensorValue[potent_left_lift];
        //current_right = 4000 - SensorValue[potent_right_lift];
        lift_current_right = lift_current_left;

        float new_left = step_pid(0.3, 0.2, 0.4,
                                  lift_requested_left,
                                  lift_current_left,
                                  &last_error_left,
                                  &integral_left);

        float new_right = step_pid(0.3, 0.2, 0.4,
                                   lift_requested_right,
                                   lift_current_right,
                                   &last_error_right,
                                   &integral_right);

        //writeDebugStream("r: %.2f c: %.2f n: %.2f\n", lift_requested_left, lift_current_left, new_left);

        new_left  = clamp(new_left, -127, 127);
        new_right = clamp(new_right, -127, 127);

        motor[lift]  = -new_left;

        wait1Msec(25);
    }
}

float lift_cone_delta = 200;

void lift_request_value_delta(float delta) {
    lift_requested_left += delta;
    lift_requested_right += delta;

    lift_requested_left  = clamp(lift_requested_left, 150, 1580);
    lift_requested_right = clamp(lift_requested_right, 150, 1580);
}

void lift_hold_current_value() {
    lift_requested_left  = lift_current_left;
    lift_requested_right = lift_current_right;
}

float arm_requested_left = 3500;
float arm_requested_right = 3500;
float arm_current_left   = 0;
float arm_current_right = 0;

bool arm_disabled = false;

task arm_pid_loop() {
    float last_error_left;
    float last_error_right;

    float integral_left = 0.0;
	float integral_right;

    while (true) {
    	if(arm_disabled) continue;

        arm_current_left = SensorValue[potent_arm_left];
		arm_current_right = SensorValue[potent_arm_right]

        float new_left = step_pid(0.2, 0.0, 0.2,
                                   arm_requested_left,
                                   arm_current_left,
                                   &last_error_left,
                                   &integral_left);

        float new_right = step_pid(0.2, 0.0, 0.2,
        						   arm_requested_right,
        						   arm_current_right,
        						   &last_error_right,
        						   &integral_right);

        new_left = clamp(new_left, -127, 127);
		new_right = clamp(new_right, -127, 127);

		if(abs(new_left) > 80) {
			new_left = 127 * sgn(new_left);
		}

		if(abs(new_right) > 80) {
			new_right = 127 * sgn(new_right);
		}


        motor[arm]  = new_left;
        //motor[] = -new_right;

        wait1Msec(25);
    }
}

void arm_request_value_delta(float delta) {
    arm_requested_left -= delta;
	arm_requested_right -= delta;

    arm_requested_left = clamp(arm_requested_left, 1850, 3400);
    arm_requested_right= clamp(arm_requested_right, 1850, 3400);
}

void arm_hold_value() {
    arm_requested_left = arm_current_left;
    arm_requested_right = arm_current_right;
}

task lcd_task();

void init() {
    stop_tasks_between_mode = true;
    startTask(lcd_task);
}

void forward(float amount) {
    drive_requested_right -= amount;
    drive_requested_left += amount;
}
void turn(float amount) {
    drive_requested_right += amount;
    drive_requested_left += amount;
}

bool at_dest(float threshold) {
    if (abs(drive_requested_left - drive_current_left) < threshold &&
        abs(drive_requested_right - drive_current_right) < threshold) {
        drive_integral_left  = 0;
        drive_integral_right = 0;
        return true;
    }

    return false;
}

void wait_for_dest(int timeout_ticks) {
    int curr = timeout_ticks;
    while (!at_dest(200) && curr >= 0) {
        wait1Msec(10);
        --curr;
        //clearLCDLine(0);
        //displayLCDNumber(0, 0, curr, 2);
    }

    if (curr == 0) {
        displayLCDString(0, 0, "MISSED!!");
        drive_requested_left   = drive_current_left;
        drive_requested_right  = drive_current_right;
        drive_last_error_left  = 0;
        drive_last_error_right = 0;
    }
}

void set_lift(int power) {
	motor[lift] = power
}

// positive for up, negative for down
void set_arm(int power) {
	motor[arm] = power;
}

void claw(int power) {
    motor[roller] = power;
}


enum {
    autostack_requested = 0,
    autostack_pop_arm_up,
    autostack_pop_arm_down,
    autostack_go_up,
    autostack_top_reached,
    autostack_release_cone_predrop_delay,
    autostack_release_cone,
    autostack_release_cone_lift_down,
    autostack_go_down_lift_up,
    autostack_go_down_arm_out,
    autostack_go_down,
    autostack_finished_arm_up,
    autostack_finished,
};

int autostack_state = autostack_finished;

int autostack_drop_delay = 0;
int autostack_predrop_delay = 0;

int autostack_current_height = 0;

// TODO: min is now 2000

/*
int autostack_values[] = {
	740,
	820,
	950,
	1030,
	1170, // problem here going down
	1230,
	1350,
	1450,
	1570,
	1640
};
*/
int autostack_values[] = {
	1420,
	1320,
	1220,
	1120,
	1020,
	920,
	820,
	720,
	620,
	520,
	420,
};

const int autostack_current_height_max = (sizeof(autostack_values)/sizeof(int)) -1;
const int autostack_current_height_min = 0;
float autostack_lift_finish_value;
float autostack_lift_up_value;

void autostack_frame() {
	//displayLCDNumber(1, 12, autostack_state);
    if (autostack_state == autostack_finished) return; // nothing to do

	//displayLCDNumber(0, 0, autostack_state);

    clearLCDLine(0);
    clearLCDLine(1);

	displayLCDNumber(0, 0, SensorValue[potent_left_lift]);
	displayLCDNumber(0, 5, SensorValue[potent_arm_left]);
	displayLCDNumber(0, 10, SensorValue[potent_arm_right]);
	displayLCDNumber(1, 0, autostack_current_height);
	displayLCDNumber(1, 4, autostack_lift_finish_value, 2);

    if (autostack_state == autostack_requested) autostack_state = autostack_go_up;

    lift_disabled = false;
    arm_disabled = false;

    if(autostack_state == autostack_pop_arm_up) {
		if(SensorValue[potent_arm_left] > 3000) {
			arm_request_value_delta(200);
		} else {
			autostack_state = autostack_pop_arm_down;
		}
	}

	if(autostack_state == autostack_pop_arm_down) {
		if(SensorValue[potent_arm_left] < 3500) {
			arm_request_value_delta(-200);
		} else {
			autostack_state = autostack_go_up;
		}
	}

    if (autostack_state == autostack_go_up) {
    	if(autostack_lift_finish_value == 0) autostack_lift_finish_value = SensorValue[potent_left_lift];

        if (SensorValue[potent_left_lift] > autostack_values[autostack_current_height]) {
            lift_request_value_delta(-150);
        } else {
            lift_hold_current_value();

            autostack_state = autostack_top_reached;
        }
    }

    if (autostack_state == autostack_top_reached) {
        if (SensorValue[potent_arm_left] > 1800) {
            arm_request_value_delta(100);
        } else {
            arm_hold_value();

            autostack_lift_up_value = SensorValue[potent_left_lift];

            autostack_state = autostack_release_cone_predrop_delay;
        }
    }

    if(autostack_state == autostack_release_cone_predrop_delay) {
    	//lift_request_value_delta(-50);

    	if(autostack_predrop_delay < 10) {
    		autostack_predrop_delay += 1;
    	} else {
    		autostack_predrop_delay = 0;
    		autostack_state = autostack_release_cone_lift_down;
    	}
    }

    if (autostack_state == autostack_release_cone) {
    	motor[roller]   = -127;
        if (autostack_predrop_delay < 30) {
        	autostack_predrop_delay += 1;
        } else {
        	autostack_predrop_delay = 0;
            autostack_state = autostack_go_down_arm_out;
        }
    }

    if (autostack_state == autostack_release_cone_lift_down) {
        lift_request_value_delta(500);

        if (autostack_drop_delay < 20) {
            autostack_drop_delay += 1;
        } else {
            motor[roller]   = -127;
            autostack_state = autostack_go_down_lift_up;
            autostack_drop_delay = 0;
        }
    }

    if(autostack_state == autostack_go_down_lift_up) {
    	if(SensorValue[potent_left_lift] > autostack_lift_up_value) {
    		lift_request_value_delta(-500);
    	} else {
    		lift_hold_current_value();
    		autostack_state = autostack_go_down_arm_out;
    	}
    }


    if (autostack_state == autostack_go_down_arm_out) {
        if (SensorValue[potent_arm_left] < 3300) {
            arm_request_value_delta(-140);
        } else {
        	arm_hold_value();
            autostack_state = autostack_go_down;
        }
    }

    if (autostack_state == autostack_go_down) {
        if (SensorValue[potent_left_lift] < autostack_lift_finish_value && SensorValue[potent_left_lift] < 1750) {
            lift_request_value_delta(500);
        } else {
        	lift_hold_current_value();

        	autostack_current_height += 1;

            autostack_state = autostack_finished;
        }
    }

    if(autostack_state == autostack_finished_arm_up) {
    	if(SensorValue[potent_arm_left] < 2400) {
    		arm_request_value_delta(70);
    	} else {
    		arm_hold_value();
    		autostack_state = autostack_finished;
    	}
    }

    if (autostack_state == autostack_finished) {
        motor[lift]  = 0;
        //motor[lift_right] = 0;

        motor[arm]  = 0;
        //motor[arm_right] = 0;

        autostack_lift_finish_value = 0;
    }

    wait1Msec(10);
}

void auton_autostack_helper() {
	int autostack_timeout = 0;
	autostack_state = autostack_requested;
	while(autostack_state != autostack_finished) {
		autostack_frame();
		if(autostack_timeout >= 200) autostack_state = autostack_go_down_arm_out;
		if(autostack_timeout >= 300) autostack_state = autostack_finished;
		autostack_timeout += 1;
	}

	autostack_state = autostack_finished;

	autostack_timeout = 0;
}

task auton() {
    // Make sure the pid loop is restarted properly
    // This will get rid of residue
    //stopTask(pid_loop);
    //startTask(pid_loop);

    // Clear other sensors that we might use in the future
    //SensorValue[claw_potent]       = 0;
    //SensorValue[left_line_sensor]  = 0;
    //SensorValue[right_line_sensor] = 0;

	SensorValue[encoder_left] = 0;
	SensorValue[encoder_right] = 0;
	drive_requested_left = 0;
	drive_requested_right = 0;
	drive_last_error_left = 0;
	drive_last_error_right = 0;

	stopTask(drive_pid);
	stopTask(drive_pid);
	stopTask(drive_pid);
	stopTask(drive_pid);
	stopTask(drive_pid);
	stopTask(drive_pid);
	stopTask(drive_pid);
	stopTask(drive_pid);
	stopTask(drive_pid);

	startTask(drive_pid);

	stopTask(arm_pid_loop);
	startTask(arm_pid_loop);

	stopTask(lift_pid_loop);
	startTask(lift_pid_loop);

	lift_disabled = false;
	arm_disabled = false;

    // potential for new
    int auton_option = (int)constants[auton_choice];

    autostack_current_height = 1;

    lift_requested_left = 1580;
    lift_requested_right = 1580;

    // release the kraken
    lift_request_value_delta(-500);
    //arm_request_value_delta(-3000);
	arm_requested_left = 3500;
	arm_requested_right = 3500;

    bLCDBacklight = true;
    clearLCDLine(0);

    switch (auton_option) {
    case 1:

    	motor[roller] = 100;

    	motor[mogo] = 127;
    	wait1Msec(1000);
    	forward(1500);
    	wait1Msec(1000);
    	motor[mogo] = 40;

    	motor[roller] = 80;

    	wait_for_dest(1000);

    	// put the arm out and drop the cone onto the stack
    	motor[roller] = -127;
    	wait1Msec(200);

    	// move the lift out of the way
    	//lift_request_value_delta(-500);

    	motor[mogo] =  -127;
    	unsigned long forward_start_time = nPgmTime;

    	forward(300);
    	wait_for_dest(1000);

    	unsigned long time_elapsed = nPgmTime - forward_start_time;

    	wait1Msec(1000 - time_elapsed);

    	motor[mogo] = -40;

    	// second cone starts here
    	motor[roller] = 100;

    	// lift all the way down
    	lift_request_value_delta(2000);

    	wait1Msec(700);

    	// already does waits for me
    	autostack_current_height = 1;
    	auton_autostack_helper();

    	motor[roller] = 100;

    	// third cone

    	lift_request_value_delta(-1000);
    	arm_request_value_delta(500);
    	forward(250);
    	wait_for_dest(300);

    	arm_request_value_delta(-1000);
    	lift_request_value_delta(2000);
    	wait1Msec(700);

    	autostack_current_height = 2;
    	auton_autostack_helper();

    	forward(300);

	   	// STACKING FINISHES HERE

    	forward(-1750);

    	motor[roller] = 0;

    	wait_for_dest(1000);

    	lift_request_value_delta(-600);
    	arm_request_value_delta(2000);

    	// TODO: NEGATIVE FOR RED
    	turn(-650);

    	wait_for_dest(1000);

    	forward(800);

    	wait_for_dest(1000);

    	// TODO: negative for RED
    	turn(-400);

    	wait_for_dest(1000);

    	forward(1000);

    	wait1Msec(300);

    	motor[mogo] = 127;

    	wait1Msec(300);

    	wait_for_dest(100);

    	forward(-500);

    	motor[mogo] = -127;
    	wait1Msec(1000);
    	motor[mogo] = 0;

    	wait_for_dest(1000);

    	// put the arm down now we are done
    	lift_request_value_delta(2000);

    	break;
    }

    // Stop pid and stop all motors to prevent drifting around
    //stopTask(pid_loop);
    all_motors_off();
}

// Some state variables for persistance
enum {
    roller_open   = 0,
    roller_closed = 1,
};

int   requested_roller = roller_closed;
float claw_change      = 0.0;

enum {
    mogo_down = 0,
    mogo_up   = 1,
};
int requested_mogo = mogo_down;

bool lift_changing_now = false;

int autostack_height_change_sign = 0;

bool pid_lock_was_pressed = false;
bool pid_lock = false;
bool disable_was_pressed = false;

float default_p;
float default_i;
float default_d;

bool disabled = false;

task user_control() {

	stopTask(auton);
    stopTask(lift_pid_loop);
    stopTask(drive_pid);
    stopTask(arm_pid_loop);

    startTask(lift_pid_loop);
    startTask(arm_pid_loop);
    startTask(lcd_task);

    while (true) {
        //clearLCDLine(0);
        //clearLCDLine(1);

        bLCDBacklight = true;

        if(autostack_state == autostack_finished) {
	        //displayLCDNumber(0, 0, SensorValue[potent_left_lift]);
	        //displayLCDNumber(1, 0, SensorValue[potent_right_lift]);

	        //displayLCDNumber(0, 7, SensorValue[sonar_lift]);
	        //displayLCDNumber(1, 7, SensorValue[potent_arm]);

	        //displayLCDNumber(0, 12, autostack_state);

       		//displayLCDNumber(0, 0, SensorValue[encoder_left]);
       		//displayLCDNumber(1, 0, SensorValue[encoder_right]);

        	//displayLCDNumber(0, 0, SensorValue[potent_arm_left]);
        	//displayLCDNumber(1, 0, SensorValue[potent_arm_right]);
	   	}

	   	if(vexRT[Btn6UXmtr2]) {
	   		disable_was_pressed = true;
	   	} else if(disable_was_pressed) {
			disable_was_pressed = false;
			disabled = !disabled;
	   	}

	   	if(disabled) {
	   		all_motors_off();
	   		continue;
		}

		if(!pid_lock)
		{
	        int r = (vexRT[Ch3] - vexRT[Ch1]);
	        int l = (vexRT[Ch3] + vexRT[Ch1]);

	        // account for deadzone
	        if (abs(l) < 20) l = 0;
	        if (abs(r) < 20) r = 0;

	        motor[right_middle]     = -r;
	        motor[right_back] = -r;
	        motor[right_front] = -r;

	        motor[left_middle]     = l;
	        motor[left_back] = l;
	      	motor[left_front] = l;
	    }

	    if(vexRT[Btn5UXmtr2]) {
	    	pid_lock_was_pressed = true;
	    } else if(pid_lock_was_pressed) {
			pid_lock = !pid_lock;
			pid_lock_was_pressed = false;

			if(pid_lock) {
				// We are starting the pid lock...
				default_p = constants[drive_constant_p];
				default_i = constants[drive_constant_i];
				default_d = constants[drive_constant_d];

				stopTask(drive_pid);
				startTask(drive_pid);

				constants[drive_constant_p] = 4.0;
				constants[drive_constant_i] = 0.0;
				constants[drive_constant_d] = 0.1;
			} else {
				stopTask(drive_pid);
				constants[drive_constant_p] = default_p;
				constants[drive_constant_i] = default_i;
				constants[drive_constant_d] = default_d;
			}
		}

        // Autostack control
        autostack_frame();

        if (vexRT[Btn8LXmtr2] == true) {
        	//autostack_current_height -= 1;
            autostack_state = autostack_go_down_arm_out;
        }
        if(vexRT[Btn7LXmtr2] == true) {
        	autostack_state = autostack_finished;
        }

        if(vexRT[Btn7UXmtr2] == true) {
        	autostack_height_change_sign = -1;
        } else if(vexRT[Btn7DXmtr2] == true) {
        	autostack_height_change_sign = 1;
        } else {
    		autostack_current_height = clamp(autostack_current_height + autostack_height_change_sign, autostack_current_height_min, autostack_current_height_max);
    		autostack_height_change_sign = 0;
        }


        // check whether autostack is active in order to see whether the user can do controls right now
        if (autostack_state != autostack_finished) {
        	lift_disabled = false;
        	continue;
        } else {
        	lift_request_value_delta(1000);
    		lift_disabled = true;

    		//arm_request_value_delta(-1000);
        }

        if (vexRT[Btn7R] == true) {
            lift_disabled = !lift_disabled;
        }

        // move the arm
        int lift_sign = 0;
        if (vexRT[Btn6U] == true) {
            lift_sign = 1;
        } else if (vexRT[Btn6D] == true) {
            lift_sign = -1;
        }/* else if(lift_changing_now == true) {
        	lift_hold_current_value();
        	lift_changing_now = false;
        }*/

        //if(lift_sign != 0) lift_changing_now = true;
        //lift_disabled = lift_changing_now;

        //if(lift_changing_now) {
        	motor[lift] = 127 * -lift_sign;
        	//motor[lift_right] = 127 * lift_sign;
		//}
        //lift_request_value_delta(lift_sign * 2);

        int arm_sign = 0;
        if (vexRT[Btn5U] == true) {
            arm_sign = 1;
        } else if (vexRT[Btn5D] == true) {
            arm_sign = -1;
        }

        arm_request_value_delta(arm_sign * 100);

        //motor[arm_left] = 127 * -arm_sign;
        //motor[arm_right] = 127 * arm_sign;

        //float current_potent = SensorValue[claw_potent]
        //float change = current_potent - claw_change;
        //claw_change = current_potent;

        bool roller_stopped = false;

        //if(change == 0) roller_stopped = true;

        // move the roller
        requested_roller = roller_closed;

        if (vexRT[Btn8U] == true) {
            requested_roller = roller_open;
        }

        if (requested_roller == roller_open) {
            motor[roller] = -127;
        } else if (requested_roller == roller_closed) {
            motor[roller] = 60;
        } else {
            motor[roller] = 0;
        }

        if (vexRT[Btn7U] == true) {
            requested_mogo = mogo_up;
            motor[mogo]    = 127;
        } else if (vexRT[Btn7D] == true) {
            requested_mogo = mogo_down;
            motor[mogo]    = -127;
        } else if (requested_mogo == mogo_down) {
            motor[mogo] = -40; // constant power holds the stack upright
        } else if (requested_mogo == mogo_up){
            motor[mogo] = 40;
        }

        if (vexRT[Btn8RXmtr2] == true) {
            autostack_state = autostack_requested; // LETS GO BOIS
        }
    }
}

// LCD CODE
void lcd_change_variable(int index) {
	int last_buttons = 0;
	int current_buttons = 0;

	string current_string = constants_strings[index];

	float value_interval = constants[interval_value];

	while(true) {
		clearLCDLine(0);
		clearLCDLine(1);

		current_buttons = nLCDButtons;

		if((last_buttons & 2) && !(current_buttons & 2)) {
			// Do the submenu
			return;
		}
		if((last_buttons & 1) && !(current_buttons & 1)) {
			//displayLCDString(1, 0, "LEFT!");
			constants[index] -= value_interval;
		}
		if((last_buttons & 4) && !(current_buttons & 4)) {
			//displayLCDString(1, 0, "RIGHT!");
			constants[index] += value_interval;
		}

		displayLCDChar(0, 0, '<');
		displayLCDChar(0, 15, '>');
		string dest;
		sprintf(dest, "%f", constants[index]);
		displayLCDCenteredString(0, dest);
		displayLCDCenteredString(1, current_string);

		last_buttons = current_buttons;

		wait1Msec(100);
	}
}

void lcd_display_variables() {
	int last_buttons = 0;
	int current_buttons;

	int current_option = 0;

	while(true) {
		clearLCDLine(0);
		clearLCDLine(1);

		current_buttons = nLCDButtons;

		int current_index = abs(current_option % constants_count);

		if((last_buttons & 2) && !(current_buttons & 2)) {
			// Do the submenu
			lcd_change_variable(current_index);
		}
		if((last_buttons & 1) && !(current_buttons & 1)) {
			//displayLCDString(1, 0, "LEFT!");
			current_option -= 1;
		}
		if((last_buttons & 4) && !(current_buttons & 4)) {
			//displayLCDString(1, 0, "RIGHT!");
			current_option += 1;
		}

		displayLCDCenteredString(0, constants_strings[current_index]);
		displayLCDCenteredString(1, "Select var");
		displayLCDChar(1, 0, '<');
		displayLCDChar(1, 15, '>');

		last_buttons = current_buttons;

		wait1Msec(100);
	}
}

task lcd_task() {
	constants[interval_value] = 0.1;
	lcd_display_variables();
}
