#pragma config(Sensor, in1,    potent_left_lift, sensorPotentiometer)
#pragma config(Sensor, in2,    potent_right_lift, sensorPotentiometer)
#pragma config(Sensor, in3,    potent_arm_left, sensorPotentiometer)
#pragma config(Sensor, in4,    potent_arm_right, sensorPotentiometer)
#pragma config(Sensor, in8,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  encoder_left,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encoder_right,  sensorQuadEncoder)
#pragma config(Motor,  port1,           roller,        tmotorNone, openLoop)
#pragma config(Motor,  port2,           left_middle,   tmotorNone, openLoop)
#pragma config(Motor,  port3,           arm_left,      tmotorNone, openLoop)
#pragma config(Motor,  port4,           left_front_back, tmotorNone, openLoop)
#pragma config(Motor,  port5,           lift_left,     tmotorNone, openLoop)
#pragma config(Motor,  port6,           arm_right,     tmotorNone, openLoop)
#pragma config(Motor,  port7,           right_front_back, tmotorNone, openLoop)
#pragma config(Motor,  port8,           lift_right,    tmotorNone, openLoop)
#pragma config(Motor,  port9,           right_middle,  tmotorNone, openLoop)
#pragma config(Motor,  port10,          mogo,          tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "robotc_base_include.c"

// utilitys for numbers
// unfortunately we do not have the safety of C++ templates...

#define max(x, a) (x > a ? x : a)
#define min(x, a) (x < a ? x : a)
#define clamp(x, a, b) (min(b, max(a, x)))

float max_speed = 127.0;

void get_requested_delta(float *left, float *right) {
    int r = (vexRT[Ch1] - vexRT[Ch3]);
    int l = (vexRT[Ch1] + vexRT[Ch3]);

    *left  = abs(l) > 20 ? l : 0;
    *right = abs(r) > 20 ? r : 0;
}

float step_pid(float  constant_p,
               float  constant_i,
               float  constant_d,
               float  requested,
               float  current_value,
               float *last_error,
               float *integral) {
    float error = current_value - requested;

    float derivitive = error - *last_error;
    *last_error      = error;

    if (constant_i != 0 && abs(error) < 50) {
        *integral = *integral + error;
    } else {
        *integral = 0;
    }

    return constant_p * error +
           constant_i * *integral +
           constant_d * derivitive;
}


// These values are exposed here to allow helper functions to access them
float drive_requested_left  = 0.0;
float drive_requested_right = 0.0;

float drive_current_left  = 0.0;
float drive_current_right = 0.0;

float drive_integral_left;
float drive_integral_right;

float drive_last_error_left;
float drive_last_error_right;

float drive_constant_p = 0.2;
float drive_constant_i = 0.0;
float drive_constant_d = 0.1;


task drive_pid() {
    // clear out the encoder
    SensorValue[encoder_left]  = 0;
    SensorValue[encoder_right] = 0;

    drive_current_left  = 0;
    drive_current_right = 0;

    drive_requested_left  = 0;
    drive_requested_right = 0;

    drive_last_error_left  = 0;
    drive_last_error_right = 0;

    drive_integral_left  = 0;
    drive_integral_right = 0;

    bool reset = true;

    while (true) {
        drive_current_left  = SensorValue[encoder_left];
        drive_current_right = SensorValue[encoder_right];

        // Since pid is only used in autonomous this code is commented out to prevent future problems.
        /*
        // get new usercontrol values here
        float delta_requested_left  = 0;
        float delta_requested_right = 0;

        get_requested_delta(&delta_requested_left, &delta_requested_right);


        if (delta_requested_left == 0 && delta_requested_right == 0) {
            if (reset) {
                requested_left             = 0;
                requested_right            = 0;
                SensorValue[left_encoder]  = 0;
                SensorValue[right_encoder] = 0;

                last_error_left  = 0;
                last_error_right = 0;

                reset = false;
            }
        } else {
            requested_left += delta_requested_left / 20;
            requested_right += delta_requested_right / 20;

            reset = true;
        }
		*/

        float new_left  = step_pid(0.2, 0.0, 0.1,
                                  drive_requested_left,
                                  drive_current_left,
                                  &drive_last_error_left,
                                  &drive_integral_left);
        float new_right = step_pid(0.2, 0.0, 0.1,
                                   drive_requested_right,
                                   drive_current_right,
                                   &drive_last_error_right,
                                   &drive_integral_right);

        if (abs(new_left) < 20) new_left = 0;
        if (abs(new_right) < 20) new_right = 0;

        writeDebugStreamLine("r: %.2f %.2f c: %.2f %.2f e: %.2f %.2f", drive_requested_left, drive_requested_right, drive_current_left, drive_current_right, drive_last_error_left, drive_last_error_right);

        new_left  = clamp(new_left, -max_speed, max_speed);
        new_right = clamp(new_right, -max_speed, max_speed);

        motor[right_middle ]       = -new_right;
        motor[right_front_back] = -new_right;

        motor[left_middle]       = -new_left;
        motor[left_front_back] = -new_left;
	}
}


float lift_requested_left  = 2100;
float lift_requested_right = 2100;

float lift_current_left;
float lift_current_right;

bool lift_disabled = false;

task lift_pid_loop() {
    SensorValue[potent_left_lift]  = 0;
    SensorValue[potent_right_lift] = 0;

    float last_error_left;
    float last_error_right;

    float integral_left  = 0.0;
    float integral_right = 0.0;

    while (true) {
        if (lift_disabled) {
            continue;
        }

        lift_current_left = SensorValue[potent_left_lift];
        //current_right = 4000 - SensorValue[potent_right_lift];
        lift_current_right = lift_current_left;

        float new_left = step_pid(0.2, 0.0, 0.1,
                                  lift_requested_left,
                                  lift_current_left,
                                  &last_error_left,
                                  &integral_left);

        float new_right = step_pid(0.2, 0.0, 0.1,
                                   lift_requested_right,
                                   lift_current_right,
                                   &last_error_right,
                                   &integral_right);

        //writeDebugStream("r: %.2f c: %.2f n: %.2f\n", lift_requested_left, lift_current_left, new_left);

        new_left  = clamp(new_left, -127, 127);
        new_right = clamp(new_right, -127, 127);

        motor[lift_left]  = new_left;
        motor[lift_right] = -new_right;

        wait1Msec(25);
    }
}

float lift_cone_delta = 200;

void lift_request_value_delta(float delta) {
    lift_requested_left += delta;
    lift_requested_right += delta;

    lift_requested_left  = clamp(lift_requested_left, 600, 1900);
    lift_requested_right = clamp(lift_requested_right, 600, 1900);
}

void lift_hold_current_value() {
    lift_requested_left  = lift_current_left;
    lift_requested_right = lift_current_right;
}

float arm_requested_left = 3600;
float arm_requested_right = 3600;
float arm_current_left   = 0;
float arm_current_right = 0;

bool arm_disabled = false;

task arm_pid_loop() {
    float last_error_left;
    float last_error_right;

    float integral_left = 0.0;
	float integral_right

    while (true) {
    	if(arm_disabled) continue;

        arm_current_left = SensorValue[potent_arm_left];
		arm_current_right = SensorValue[potent_arm_right]

        float new_left = step_pid(0.2, 0.0, 0.3,
                                   arm_requested_left,
                                   arm_current_left,
                                   &last_error_left,
                                   &integral_left);

        float new_right = step_pid(0.1, 0.0, 0.3,
        						   arm_requested_right,
        						   arm_current_right,
        						   &last_error_right,
        						   &integral_right);

        new_left = clamp(new_left, -127, 127);
		new_right = clamp(new_right, -127, 127);


        motor[arm_left]  = new_left;
        motor[arm_right] = -new_right;

        wait1Msec(25);
    }
}

void arm_request_value_delta(float delta) {
    arm_requested_left -= delta;
	arm_requested_right -= delta;

    arm_requested_left = clamp(arm_requested_left, 1750, 3800);
    arm_requested_right= clamp(arm_requested_right, 1750, 3800);
}

void arm_hold_value() {
    arm_requested_left = arm_current_left;
    arm_requested_right = arm_current_right;
}

void init() {
    stop_tasks_between_mode = true;
}

void forward(float amount) {
    drive_requested_right -= amount;
    drive_requested_left += amount;
}
void turn(float amount) {
    drive_requested_right += amount;
    drive_requested_left += amount;
}

bool at_dest(float threshold) {
    if (abs(drive_requested_left - drive_current_left) < threshold &&
        abs(drive_requested_right - drive_current_right) < threshold) {
        drive_integral_left  = 0;
        drive_integral_right = 0;
        return true;
    }

    return false;
}

void wait_for_dest(int timeout_ticks) {
    int curr = timeout_ticks;
    while (!at_dest(200) && curr >= 0) {
        wait1Msec(10);
        --curr;
        //clearLCDLine(0);
        //displayLCDNumber(0, 0, curr, 2);
    }

    if (curr == 0) {
        displayLCDString(0, 0, "MISSED!!");
        drive_requested_left   = drive_current_left;
        drive_requested_right  = drive_current_right;
        drive_last_error_left  = 0;
        drive_last_error_right = 0;
    }
}

void lift(int power) {
    motor[lift_left]  = power;
    motor[lift_right] = -power;
}

// positive for up, negative for down
void arm(int power) {
    motor[arm_left]  = -power;
    motor[arm_right] = power;
}

void claw(int power) {
    motor[roller] = power;
}


enum {
    autostack_requested = 0,
    autostack_pop_arm_up,
    autostack_pop_arm_down,
    autostack_go_up,
    autostack_top_reached,
    autostack_release_cone_predrop_delay,
    autostack_release_cone,
    autostack_release_cone_lift_down,
    autostack_go_down_lift_up,
    autostack_go_down_arm_out,
    autostack_go_down,
    autostack_finished_arm_up,
    autostack_finished,
};

int autostack_state = autostack_finished;

int autostack_drop_delay = 0;
int autostack_predrop_delay = 0;

int autostack_current_height = 0;
int autostack_values[] = {
	740,
	820,
	950,
	1030,
	1170, // problem here going down
	1230,
	1350,
	1450,
	1570,
	1640
};
const int autostack_current_height_max = (sizeof(autostack_values)/sizeof(int)) -1;
const int autostack_current_height_min = 0;
float autostack_lift_finish_value;

void autostack_frame() {
	//displayLCDNumber(1, 12, autostack_state);
    if (autostack_state == autostack_finished) return; // nothing to do

	//displayLCDNumber(0, 0, autostack_state);
	displayLCDNumber(0, 0, SensorValue[potent_left_lift]);
	displayLCDNumber(0, 5, SensorValue[potent_arm_left]);
	displayLCDNumber(0, 9, SensorValue[potent_arm_right]);
	displayLCDNumber(1, 0, autostack_current_height);
	displayLCDNumber(1, 3, autostack_lift_finish_value, 2);

    if (autostack_state == autostack_requested) autostack_state = autostack_go_up;

    lift_disabled = false;
    arm_disabled = false;

    if(autostack_state == autostack_pop_arm_up) {
		if(SensorValue[potent_arm_left] > 3000) {
			arm_request_value_delta(200);
		} else {
			autostack_state = autostack_pop_arm_down;
		}
	}

	if(autostack_state == autostack_pop_arm_down) {
		if(SensorValue[potent_arm_left] < 3500) {
			arm_request_value_delta(-200);
		} else {
			autostack_state = autostack_go_up;
		}
	}

    if (autostack_state == autostack_go_up) {
    	if(autostack_lift_finish_value == 0) autostack_lift_finish_value = SensorValue[potent_left_lift];

        if (SensorValue[potent_left_lift] < autostack_values[autostack_current_height]) {
            lift_request_value_delta(150);
        } else {
            lift_hold_current_value();

            autostack_state = autostack_top_reached;
        }
    }

    if (autostack_state == autostack_top_reached) {
        if (SensorValue[potent_arm_left] > 1850) {
            arm_request_value_delta(100);
        } else {
            arm_hold_value();
            autostack_state = autostack_release_cone_predrop_delay;
        }
    }

    if(autostack_state == autostack_release_cone_predrop_delay) {
    	//lift_request_value_delta(-50);

    	if(autostack_predrop_delay < 10) {
    		autostack_predrop_delay += 1;
    	} else {
    		autostack_predrop_delay = 0;
    		autostack_state = autostack_release_cone;
    	}
    }

    if (autostack_state == autostack_release_cone) {
    	motor[roller]   = -127;
        if (autostack_predrop_delay < 30) {
        	autostack_predrop_delay += 1;
        } else {
        	autostack_predrop_delay = 0;
            autostack_state = autostack_go_down_arm_out;
        }
    }

    if (autostack_state == autostack_release_cone_lift_down) {
        lift_request_value_delta(-300);

        if (autostack_drop_delay < 3) {
            autostack_drop_delay += 1;
        } else {
            motor[roller]   = -127;
            autostack_state = autostack_go_down_lift_up;
            autostack_drop_delay = 0;
        }
    }

    if (autostack_state == autostack_go_down_arm_out) {
        if (SensorValue[potent_arm_left] < 3400) {
            arm_request_value_delta(-140);
        } else {
        	arm_hold_value();
            autostack_state = autostack_go_down;
        }
    }

    if (autostack_state == autostack_go_down) {
        if (SensorValue[potent_left_lift] > autostack_lift_finish_value) {
            lift_request_value_delta(-300);
        } else {
        	lift_hold_current_value();

        	autostack_current_height += 1;

            autostack_state = autostack_finished;
        }
    }

    if(autostack_state == autostack_finished_arm_up) {
    	if(SensorValue[potent_arm_left] < 2400) {
    		arm_request_value_delta(70);
    	} else {
    		arm_hold_value();
    		autostack_state = autostack_finished;
    	}
    }

    if (autostack_state == autostack_finished) {
        motor[lift_left]  = 0;
        motor[lift_right] = 0;

        motor[arm_left]  = 0;
        motor[arm_right] = 0;

        autostack_lift_finish_value = 0;
    }

    wait1Msec(10);
}

void auton_autostack_helper() {
	int autostack_timeout = 0;
	autostack_state = autostack_requested;
	while(autostack_state != autostack_finished) {
		autostack_frame();
		if(autostack_timeout >= 200) autostack_state = autostack_go_down_arm_out;
		if(autostack_timeout >= 300) autostack_state = autostack_finished;
		autostack_timeout += 1;
	}

	autostack_timeout = 0;
}

task auton() {
    // Make sure the pid loop is restarted properly
    // This will get rid of residue
    //stopTask(pid_loop);
    //startTask(pid_loop);

    // Clear other sensors that we might use in the future
    //SensorValue[claw_potent]       = 0;
    //SensorValue[left_line_sensor]  = 0;
    //SensorValue[right_line_sensor] = 0;

	SensorValue[encoder_left] = 0;
	SensorValue[encoder_right] = 0;

	stopTask(drive_pid);
	startTask(drive_pid);

	stopTask(arm_pid_loop);
	startTask(arm_pid_loop);

	stopTask(lift_pid_loop);
	startTask(lift_pid_loop);

    // potential for new
    int auton_option = 0;

    // release the kraken
    lift_request_value_delta(-1000);
    arm_request_value_delta(3000);

    bLCDBacklight = true;
    clearLCDLine(0);

    switch (auton_option) {
    case 0:

    	motor[roller] = 50;

    	motor[mogo] = 127;
    	wait1Msec(1000);
    	forward(1600);
    	wait1Msec(1000);
    	motor[mogo] = 0;

    	wait_for_dest(1000);

    	motor[mogo] =  -127;
    	wait1Msec(2000);
    	motor[mogo] = -15;

    	// go down drop first cone

    	lift_request_value_delta(2000);

    	wait1Msec(500);

    	motor[roller] = -127;
    	wait1Msec(500);



    	// second cone starts here

    	forward(300);
    	wait_for_dest(1000);

    	lift_request_value_delta(-1000);
    	wait1Msec(200);
    	arm_request_value_delta(-3000);
    	motor[roller] = 100;
    	wait1Msec(500);

    	// lift all the way down
    	lift_request_value_delta(1000);

    	wait1Msec(700);

    	forward(-1750);

    	auton_autostack_helper();

	   	// STACKING FINISHES HERE

    	motor[roller] = 0;

    	wait_for_dest(1000);

    	lift_request_value_delta(-600);
    	arm_request_value_delta(2000);

    	// TODO: NEGATIVE FOR RED
    	turn(-650);

    	wait_for_dest(1000);

    	forward(800);

    	wait_for_dest(1000);

    	// TODO: negative for RED
    	turn(-400);

    	wait_for_dest(1000);

    	forward(1000);

    	wait1Msec(300);

    	motor[mogo] = 127;

    	wait1Msec(300);

    	wait_for_dest(100);

    	forward(-500);

    	motor[mogo] = -127;
    	wait1Msec(1000);
    	motor[mogo] = 0;

    	wait_for_dest(1000);

    	// put the arm down now we are done
    	lift_request_value_delta(2000);

    	break;
    }

    // Stop pid and stop all motors to prevent drifting around
    //stopTask(pid_loop);
    all_motors_off();
}

// Some state variables for persistance
enum {
    roller_open   = 0,
    roller_closed = 1,
};

int   requested_roller = roller_closed;
float claw_change      = 0.0;

enum {
    mogo_down = 0,
    mogo_up   = 1,
};
int requested_mogo = mogo_up;

bool lift_changing_now = false;

int autostack_height_change_sign = 0;

task user_control() {
    sleep(500);

    stopTask(lift_pid_loop);

    startTask(lift_pid_loop);
    startTask(arm_pid_loop);

    while (true) {
        clearLCDLine(0);
        clearLCDLine(1);

        bLCDBacklight = true;

        if(autostack_state == autostack_finished) {
	        //displayLCDNumber(0, 0, SensorValue[potent_left_lift]);
	        //displayLCDNumber(1, 0, 4000 - SensorValue[potent_right_lift]);

	        //displayLCDNumber(0, 7, SensorValue[sonar_lift]);
	        //displayLCDNumber(1, 7, SensorValue[potent_arm]);

	        //displayLCDNumber(0, 12, autostack_state);

       		//displayLCDNumber(0, 0, SensorValue[encoder_left]);
       		//displayLCDNumber(1, 0, SensorValue[encoder_right]);

        	displayLCDNumber(0, 0, SensorValue[potent_arm_left];
        	displayLCDNumber(1, 0, SensorValue[potent_arm_right];
	   	}

        int r = (vexRT[Ch3] - vexRT[Ch1]);
        int l = (vexRT[Ch3] + vexRT[Ch1]);

        // account for deadzone
        if (abs(l) < 20) l = 0;
        if (abs(r) < 20) r = 0;

        motor[right_middle]     = -r;
        motor[right_front_back] = -r;

        motor[left_middle]     = l;
        motor[left_front_back] = l;

        // Autostack control
        autostack_frame();

        if (vexRT[Btn8LXmtr2] == true) {
        	//autostack_current_height -= 1;
            autostack_state = autostack_go_down_arm_out;
        }
        if(vexRT[Btn7LXmtr2] == true) {
        	autostack_state = autostack_finished;
        }

        if(vexRT[Btn7UXmtr2] == true) {
        	autostack_height_change_sign = -1;
        } else if(vexRT[Btn7DXmtr2] == true) {
        	autostack_height_change_sign = 1;
        } else {
    		autostack_current_height = clamp(autostack_current_height + autostack_height_change_sign, autostack_current_height_min, autostack_current_height_max);
    		autostack_height_change_sign = 0;
        }


        // check whether autostack is active in order to see whether the user can do controls right now
        if (autostack_state != autostack_finished) {
        	lift_disabled = false;
        	continue;
        } else {
        	lift_request_value_delta(1000);
    		lift_disabled = true;

    		//arm_request_value_delta(-1000);
        }

        if (vexRT[Btn7R] == true) {
            lift_disabled = !lift_disabled;
        }

        // move the arm
        int lift_sign = 0;
        if (vexRT[Btn6U] == true) {
            lift_sign = 1;
        } else if (vexRT[Btn6D] == true) {
            lift_sign = -1;
        }/* else if(lift_changing_now == true) {
        	lift_hold_current_value();
        	lift_changing_now = false;
        }*/

        //if(lift_sign != 0) lift_changing_now = true;
        //lift_disabled = lift_changing_now;

        //if(lift_changing_now) {
        	motor[lift_left] = 127 * -lift_sign;
        	motor[lift_right] = 127 * lift_sign;
		//}
        //lift_request_value_delta(lift_sign * 2);

        int arm_sign = 0;
        if (vexRT[Btn5U] == true) {
            arm_sign = 1;
        } else if (vexRT[Btn5D] == true) {
            arm_sign = -1;
        }

        arm_request_value_delta(arm_sign * 10);

        //motor[arm_left] = 127 * -arm_sign;
        //motor[arm_right] = 127 * arm_sign;

        //float current_potent = SensorValue[claw_potent]
        //float change = current_potent - claw_change;
        //claw_change = current_potent;

        bool roller_stopped = false;

        //if(change == 0) roller_stopped = true;

        // move the roller
        requested_roller = roller_closed;

        if (vexRT[Btn8U] == true) {
            requested_roller = roller_open;
        }

        if (requested_roller == roller_open) {
            motor[roller] = -127;
        } else if (requested_roller == roller_closed) {
            motor[roller] = 60;
        } else {
            motor[roller] = 0;
        }

        if (vexRT[Btn7U] == true) {
            requested_mogo = mogo_up;
            motor[mogo]    = 127;
        } else if (vexRT[Btn7D] == true) {
            requested_mogo = mogo_down;
            motor[mogo]    = -127;
        } else if (requested_mogo == mogo_down) {
            motor[mogo] = -40; // constant power holds the stack upright
        } else {
            motor[mogo] = 0;
        }

        if (vexRT[Btn8RXmtr2] == true) {
            autostack_state = autostack_requested; // LETS GO BOIS
        }
    }
}

// silly fix because robotc doesnt parse code properly... :(
typedef float *pfloat;
pfloat constant_list[] = {
	&drive_constant_p,
	&drive_constant_i,
	&drive_constant_d,
};

string constant_list_strings[] = {
	"drive_constant_p",
	"drive_constant_i",
	"drive_constant_d",
};

// LCD CODE

task lcd_task() {

}
